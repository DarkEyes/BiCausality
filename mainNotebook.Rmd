---
title: "R Notebook"
output: html_notebook
---

t

```{r}
supp<-function(X,values)
{
  count<-0
  n<-0
  flag=0
  if(is.null(dim(X)[1]))
  {
    n<-length(X)
    flag=1
  }
  else
    n<-dim(X)[1]
  for(i in seq(n))
  {
    if(flag==1)
      row<-X[i]
    else
      row<-X[i,]
    if(sum(row==values) == length(values))
      count=count+1
  }
  return(count/n)
}
x <- rbinom(n=10, size=1, prob=0.2)
ny<-rbinom(n=10, size=1, prob=0.05)
y <- x |  ny
supp(X=cbind(x,y),values=c(1,1) )

```
#Sorting
```{r}

bin2dec<-function(x)
{
  newx<-0
  d<-length(x)
  for(i in seq(d))
  {
    newx <- newx+x[i]*2^(d-i)
  }
  return(newx)
}
VecAlignment<-function(mat)
{
  # mat must have the dimension n by d where n and d must be greater than 1.
  newMat<-list()
  d<-dim(mat)[1]
  for(i in seq(d))
  {
    newMat[[sprintf("%d",bin2dec(mat[i,]))]]$name<-mat[i,]
    if(is.null(newMat[[sprintf("%d",bin2dec(mat[i,]))]]$count)==TRUE )
      newMat[[sprintf("%d",bin2dec(mat[i,]))]]$count<-1
    else
      newMat[[sprintf("%d",bin2dec(mat[i,]))]]$count<-newMat[[sprintf("%d",bin2dec(mat[i,]))]]$count+1
  }
  return(newMat)
}

n<-500
d<-10
mat<-matrix(nrow=n,ncol=d)

for(i in seq(n))
{
  mat[i,] <- rbinom(n=d, size=1, prob=0.5)
}
mat[,1]<-mat[,2] | mat[,3]
mat[,4] <- mat[,2] | mat[,5]

D<-VecAlignment(mat)
```

#CondProb

```{r}
#z[c(1,2)]<-1
#y[c(1,2)]<-c(1,0)
# CondProb<-function(D,y,z)
# {
#   p<-0
#   filter<-z != -1
#   if(sum(filter) == 0)
#     nD<-D
#   else
#   {
#     nD<-list()
#     for(i in seq(length(D)) )
#     {
#       flag<-sum(D[[i]]$name[filter] == z[filter])
#       if(flag == sum(filter))
#       {
#         nD[[names(D)[i] ]] <- D[[i]]
#       }
#     }
#   }
#   filterY<- y!= -1
#   count<-0
#   countTotal<-0
#   for(i in seq(length(nD)) )
#   {
#     flag<-sum(nD[[i]]$name[filterY] == y[filterY])
#     countTotal<-countTotal+nD[[i]]$count
#     if(flag == sum(filterY))
#     {
#       count<-count+nD[[i]]$count
#     }
#   }
#   
#   return(list("condP"=count/countTotal, nD=nD,countTotal=countTotal,count=count ))
# }
z<-numeric(d)-1
y<-numeric(d)-1
i=1
j=2
D<-VecAlignment(mat)
y[j]<-c(1)
z[i]<-c(1)
a1<-CondProb(D,y=y,z=z)$condP
b1<-CondProb(D,y=z,z=y)$condP

a1-b1

A<-bIndpTest(mat,i,j)
causalDirTest(mat,i=i,j=j,vi=1,ths=0.25)

```


#independent func
```{r}
#TODO add given z
indpFunc<-function(D,i,j,z=c())
{
  if(is.null(z))
    z<-numeric(d)-1
  
  res<-CondProb(D,y=numeric(d)-1,z=z)
  D<-res$nD
  n<-res$countTotal
  L<-length(D)
  
  indMagitude<-0
  
  z1<-numeric(d)-1

  for(i1 in c(0,1) )
    for(j1 in c(0,1))
    {
        y1<-numeric(d) -1
        y1[c(i,j)] <- c(i1,j1)
        y2<-numeric(d) -1
        y2[c(i)] <- i1
        y3<-numeric(d) -1
        y3[c(j)] <- j1
        
        res2<-CondProb(D,y1,z1)
        n2<-res2$count
        condPair<-res2$condP
        condi<-CondProb(D,y2,z1)$condP
        condj<-CondProb(D,y3,z1)$condP
        indMagitude<-indMagitude+ (abs(condPair - condi*condj)*(n2/n) )
    }
  
  return(indMagitude)
}
z<-numeric(d)-1
z[c(4)] = 0
indpFunc(D,1,2,z=z)
z[c(4)] = 1
indpFunc(D,1,2,z=z)
```
Indp Bootstrap
```{r}
bIndpTest<-function(mat,i,j,z=c(),alpha=0.05,ths = 0.05,nboot=100)
{
  if(is.null(z))
    z<-numeric(d)-1
  #z[2]<- -1
  
  n<-dim(mat)[1]
  bDx<-matrix(0,nboot,n)
  bIndpDist<-numeric(nboot)
  for(k in seq(nboot))
  {
    bDx[k,]<-sample(1:n,length(1:n),replace = TRUE)
    nMat<-mat[bDx[k,],]
    D<-VecAlignment(nMat)
    bIndpDist[k]<-indpFunc(D,i,j,z=z)
  }
  testRes<-wilcox.test(x=bIndpDist, mu = ths, alternative = "greater")
  confInv<-quantile(bIndpDist, c(0+alpha/2, 1-alpha/2))
  bmean <- mean(bIndpDist)
  return(list(testRes=testRes,confInv=confInv,bmean=bmean))
}
```
# run
```{r}
library(BiCausality)

n<-500
d<-10
mat<-matrix(nrow=n,ncol=d)

for(i in seq(n))
{
  mat[i,] <- rbinom(n=d, size=1, prob=0.5)
}
mat[,1]<-mat[,2] | mat[,3]
mat[,4] <- !mat[,2] | mat[,5]


i=2
j=1
print(sprintf("i%d,j%d",i,j))
bIndpTest(mat,i,j)
i=2
j=4
print(sprintf("i%d,j%d",i,j))
bIndpTest(mat,i,j)
i=2
j=3
print(sprintf("i%d,j%d",i,j))
bIndpTest(mat,i,j)
i=4
j=1
print(sprintf("i%d,j%d",i,j))
bIndpTest(mat,i,j)
i=4
j=1
z<-numeric(d)-1
z[2]<-1
print(sprintf("i%d,j%d",i,j))
bIndpTest(mat,i,j,z=z)

i=2
j=3
z<-numeric(d)-1
z[1]<-0
print(sprintf("i%d,j%d",i,j))
bIndpTest(mat,i,j,z=z)
```
#oddRatio
```{r}
library(BiCausality)
n<-500
d<-10
mat<-matrix(nrow=n,ncol=d)

for(i in seq(n))
{
  mat[i,] <- rbinom(n=d, size=1, prob=0.5)
}
mat[,1]<-mat[,2] | mat[,3]
mat[,4] <- !mat[,2] | mat[,5]

z<-numeric(d)-1
y<-numeric(d)-1
i=5
j=4
D<-VecAlignment(mat)
oddRatioFunc(D,i,j)

i=4
j=5
z<-numeric(d)-1
z[5]<- -1
oddDiffFunc(D,i,j,z=z)
```
```{r}
i=2
j=1
z<-numeric(d)-1
z[2]<- -1
print(sprintf("i%d,j%d",i,j))
assocSignTest(mat,i,j,z=z)
```

```{r}

bSCMDepndentGraphFunc<-function(mat,nboot=100,alpha=0.05,IndpThs=0.05)
{
  n<-dim(mat)[1]
  d<-dim(mat)[2]
  nMatboot<-list()
  Dboot<-list()
  bDx<-matrix(0,nboot,n)
  # == Create the bootstrapping sequence of D
  for(k in seq(nboot))
  {
    bDx[k,]<-sample(1:n,length(1:n),replace = TRUE)
    nMatboot[[k]]<-mat[bDx[k,],]
    Dboot[[k]]<-VecAlignment(nMatboot[[k]])
  }
  #Check dependency of all pairwises
  E0<-matrix(0,nrow=d,ncol=d) # save mean
  depInfo<-list()
  
  for(i in seq(d-1))
    for(j in seq(i+1,d))
    {
      str<-sprintf("%d,%d",i,j)
      print(str)
      bIndpDist<-numeric(nboot)
      for(k in seq(nboot))
      {
        D<-Dboot[[k]]
        bIndpDist[k]<-indpFunc(D,i,j)
      }
      testRes<-wilcox.test(x=bIndpDist, mu = IndpThs, alternative = "greater")
      confInv<-quantile(bIndpDist, c(0+alpha/2, 1-alpha/2))
      bmean <- mean(bIndpDist)

      #check whether i is dependent with j
      if(testRes$p.value<=alpha)
      {
        E0[i,j]<-1
        E0[j,i]<-1
        depInfo[[str]]$bmean<-bmean
        depInfo[[str]]$confInv<-confInv
        depInfo[[str]]$testRes<-testRes
        depInfo[[str]]$indices<-c(i,j)
      }
    }
  return(list(E0=E0,depInfo=depInfo,Dboot=Dboot) )
}
library(BiCausality)
n<-500
d<-10
mat<-matrix(nrow=n,ncol=d)

for(i in seq(n))
{
  mat[i,] <- rbinom(n=d, size=1, prob=0.5)
}
mat[,1]<-mat[,2] | mat[,3]
mat[,4] <- !mat[,2] | mat[,5]

res<-bSCMDepndentGraphFunc(mat)
```
#Confounding factor checking
```{r}
bSCMdeConfoundingGraphFunc<-function(dat,IndpThs=0.05,alpha=0.05)
{
  E0<-dat$E0
  d<-dim(E0)[1]
  E1<-matrix(0,d,d)
  E2<-matrix(0,d,d)
  nboot<-length(dat$Dboot)
  for(info in dat$depInfo)
  {
    i<-info$indices[1]
    j<-info$indices[2]
    # i and j have another dependent var
    if(E0[i,j]==1 && sum(E0[i,])>1 && sum(E0[j,])>1)
    {
      z<- 1:d
      z<-z[E0[i,] & E0[j,]]
      flag=0
      if(length(z)>0)
        for(z0 in z)
        {
          print(sprintf("%d,%d | %d",i,j,z0))
          bIndpDist<-numeric(nboot)
          z1<-numeric(d)-1
          z1[z0]<-1
          z2<-numeric(d)-1
          z2[z0]<-0
          for(b in seq(nboot) )
          {
            nD<-dat$Dboot[[b]]
            bIndpDist[b]<- max(c(indpFunc(nD,i,j,z1), indpFunc(nD,i,j,z2) ) )
          }
          testRes<-wilcox.test(x=bIndpDist, mu = IndpThs, alternative = "greater")
          print(sprintf("pval:%f",testRes$p.value))
          #check whether i is dependent with j given z0
          if(testRes$p.value>alpha)
          {
            flag=1
            E2[i,j]<-z0
            break
          }
        }
       if(flag==0)
       {
         E1[i,j]<-1
         E1[j,i]<-1
       }

    }
    else
    {
      E1[i,j]<-1
      E1[j,i]<-1
    }
  }
  return(list(E1=E1,E2=E2))
}
res2<-bSCMdeConfoundingGraphFunc(res)
```
#Causal direction
```{r}
bSCMCausalGraphFunc<-function(E1,Dboot,alpha=0.05,SignThs=0.05,CausalThs = 0.25,slack=0.001)
{
  d<-dim(E1)[1]
  Ehat<-matrix(0,d,d)
  nboot= length(Dboot)
  bSignDist<-numeric(nboot)
  inxList<-c()
  
  causalInfo<-list()
  
  for(i in seq(1,d-1))
    for(j in seq(i+1,d))
    {
      if(E1[i,j]==1)
        inxList<-rbind(inxList, c(i,j))
    }
  
  signFlag<-numeric(dim(inxList)[1])-1
  # == Create the bootstrapping sequence of bSignDist
  
  for( itr in seq(dim(inxList)[1]) )
  {
    inx<-inxList[itr,]
    i=inx[1]
    j=inx[2]
    str<-sprintf("%d,%d",i,j)
    print(str)
    for(k in seq(nboot))
    {
      bSignDist[k]<-oddDiffFunc(D=Dboot[[k]],i=inx[1],j=inx[2],slack=slack)
    }
    testRes1<-wilcox.test(x=abs(bSignDist), mu = SignThs, alternative = "greater")
    if(testRes1$p.value<=alpha)
    {
      if(mean(bSignDist) >0)
        signFlag[itr]<-1
      else
        signFlag[itr]<-0
    }
    
    if(signFlag[itr] != -1){
    #=========TODO dir inference
      bCausalDirDist<-numeric(nboot)
      for(k in seq(nboot))
      {
        D<-Dboot[[k]]
    
        z1<-numeric(d)-1
        y1<-numeric(d)-1
        y1[j]<-1
        z1[i]<-(signFlag[itr])
        a1<-CondProb(D,y=y1,z=z1)$condP
        b1<-CondProb(D,y=z1,z=y1)$condP
        bCausalDirDist[k]<-a1-b1
      }
      testRes2<-wilcox.test(x=abs(bCausalDirDist), mu = CausalThs, alternative = "greater")
      bmean <- mean( (bCausalDirDist) )
      dirFlag=1
      if(testRes2$p.value<=alpha)
      {
        if(bmean >0) # i -> j
        {
          Ehat[i,j]<-1
          x1<-i
          y1<-j
         
        }
        else #j -> i
        {
          Ehat[j,i]<-1
          x1<-j
          y1<-i
          str<-sprintf("%d,%d",j,i)
          dirFlag=-1
        }
        causalInfo[[str]]$CDirConfInv<-abs(quantile(dirFlag*bCausalDirDist, c(0+alpha/2, 1-alpha/2)) )
        causalInfo[[str]]$CDirmean<-abs(bmean)
        causalInfo[[str]]$testRes2<-testRes2
        causalInfo[[str]]$testRes1<-testRes1
        causalInfo[[str]]$sign<-signFlag[itr]
        causalInfo[[str]]$SignConfInv<-quantile(bSignDist, c(0+alpha/2, 1-alpha/2))
        causalInfo[[str]]$Signmean<-mean(bSignDist)
      }
    }
  }
  return(list(Ehat=Ehat,causalInfo=causalInfo) )
}
res3<-bSCMCausalGraphFunc(res2$E1,res$Dboot)
```




#Running main

```{r}
library(BiCausality)
n<-500
d<-10
mat<-matrix(nrow=n,ncol=d)

for(i in seq(n))
{
  mat[i,] <- rbinom(n=d, size=1, prob=0.5)
}
mat[,1]<-mat[,2] | mat[,3] 
mat[,4] <- !mat[,2] | mat[,5] 
#mat[,7] <- !mat[,8] cannot have exact pairs to compute whether i -> j
mat[,9]<- mat[,8] | !mat[,7]

lastRes<-CausalGraphInferMainFunc(mat)
```





































s
