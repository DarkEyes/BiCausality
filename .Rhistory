newx <- newx+x[i]*2^(d-i)
}
return(newx)
}
VecAlignment<-function(mat)
{
# mat must have the dimension n by d where n and d must be greater than 1.
newMat<-list()
d<-dim(mat)[1]
for(i in seq(d))
{
newMat[[sprintf("%d",bin2dec(mat[i,]))]]$name<-mat[i,]
if(is.null(newMat[[sprintf("%d",bin2dec(mat[i,]))]]$count)==TRUE )
newMat[[sprintf("%d",bin2dec(mat[i,]))]]$count<-1
else
newMat[[sprintf("%d",bin2dec(mat[i,]))]]$count<-newMat[[sprintf("%d",bin2dec(mat[i,]))]]$count+1
}
return(newMat)
}
n<-500
d<-10
mat<-matrix(nrow=n,ncol=d)
for(i in seq(n))
{
mat[i,] <- rbinom(n=d, size=1, prob=0.5)
}
mat[,1]<-mat[,2] | mat[,3]
mat[,4] <- mat[,2] | mat[,5]
D<-VecAlignment(mat)
CondProb<-function(D,y,z) # serve as a confidence function in data mining conf(y|z)
{
p<-0
filter<-z != -1
if(sum(filter) == 0) # go full D without conditional variables
nD<-D
else # Keep only binary that are match with the given z.
{
nD<-list()
for(i in seq(length(D)) ) #For each unique binary D[[i]]
{
flag<-sum(D[[i]]$name[filter] == z[filter]) # check whether D[[i]] bits in z's positions are the same as z's
if(flag == sum(filter)) # if so, add the D[[i]] into nD
{
nD[[names(D)[i] ]] <- D[[i]]
}
}
}
filterY<- y!= -1
count<-0
countTotal<-0
for(i in seq(length(nD)) ) #For each unique binary nD[[i]] in nD
{
flag<-sum(nD[[i]]$name[filterY] == y[filterY])
countTotal<-countTotal+nD[[i]]$count
if(flag == sum(filterY)) #  check whether nD[[i]] bits in y' positions are the same as y's
{
count<-count+nD[[i]]$count
}
}
return(list("condP"=count/countTotal, nD=nD,countTotal=countTotal,count=count ))
}
z<-numeric(d)-1
y<-numeric(d)-1
# mat[,1]<-mat[,2] | mat[,3]
i=1
j=2
D<-VecAlignment(mat)
y[j]<-c(1)
z[i]<-c(1)
a1<-CondProb(D,y=y,z=z)$condP # 2|1 y|z
b1<-CondProb(D,y=z,z=y)$condP # 1|2
a1-b1
#A<-bIndpTest(mat,i,j)
#causalDirTest(mat,i=i,j=j,vi=1,ths=0.25)
#TODO add given z
indpFunc<-function(D,i,j,d,z=c())
{
if(is.null(z)) # go full D without conditional variables
z<-numeric(d)-1
res<-CondProb(D,y=numeric(d)-1,z=z) #get the total n
D<-res$nD
n<-res$countTotal
L<-length(D)
indMagitude<-0
z1<-numeric(d)-1
for(i1 in c(0,1) )
for(j1 in c(0,1))
{
y1<-numeric(d) -1
y1[c(i,j)] <- c(i1,j1) # supp(i,j)
y2<-numeric(d) -1
y2[c(i)] <- i1 #supp(i)
y3<-numeric(d) -1
y3[c(j)] <- j1 #supp(j)
res2<-CondProb(D,y1,z1)
n2<-res2$count
condPair<-res2$condP
condi<-CondProb(D,y2,z1)$condP
condj<-CondProb(D,y3,z1)$condP
# |p(i,j) -p(i)*p(j)|*weight
indMagitude<-indMagitude+ (abs(condPair - condi*condj)*(n2/n) )
}
return(indMagitude)
}
n<-500
d<-10
mat<-matrix(nrow=n,ncol=d)
for(i in seq(n))
{
mat[i,] <- rbinom(n=d, size=1, prob=0.5)
}
mat[,1]<-mat[,2] | mat[,3]
mat[,4] <- mat[,2] | mat[,5]
D<-VecAlignment(mat)
z<-numeric(d)-1
z[c(3)] = 0
indpFunc(D,1,2,d=d,z=z)
z[c(3)] = 1
indpFunc(D,1,2,d=d,z=z)
bIndpTest<-function(mat,i,j,z=c(),alpha=0.05,ths = 0.05,nboot=100)
{
if(is.null(z))
z<-numeric(d)-1
#z[2]<- -1
n<-dim(mat)[1]
bDx<-matrix(0,nboot,n)
bIndpDist<-numeric(nboot)
for(k in seq(nboot))
{
bDx[k,]<-sample(1:n,length(1:n),replace = TRUE)
nMat<-mat[bDx[k,],]
D<-VecAlignment(nMat)
bIndpDist[k]<-indpFunc(D,i,j,z=z)
}
testRes<-wilcox.test(x=bIndpDist, mu = ths, alternative = "greater")
confInv<-quantile(bIndpDist, c(0+alpha/2, 1-alpha/2))
bmean <- mean(bIndpDist)
return(list(testRes=testRes,confInv=confInv,bmean=bmean))
}
library(BiCausality)
library(devtools)
devtools::document()
library(BiCausality)
n<-500
d<-10
mat<-matrix(nrow=n,ncol=d)
for(i in seq(n))
{
mat[i,] <- rbinom(n=d, size=1, prob=0.5)
}
mat[,1]<-mat[,2] | mat[,3]
mat[,4] <- !mat[,2] | mat[,5]
i=2
j=1
print(sprintf("i%d,j%d",i,j))
bIndpTest(mat,i,j)
library(BiCausality)
n<-500
d<-10
mat<-matrix(nrow=n,ncol=d)
for(i in seq(n))
{
mat[i,] <- rbinom(n=d, size=1, prob=0.5)
}
mat[,1]<-mat[,2] | mat[,3]
mat[,4] <- !mat[,2] | mat[,5]
i=2
j=1
print(sprintf("i%d,j%d",i,j))
bIndpTest(mat,d=d,i,j)
library(BiCausality)
n<-500
d<-10
mat<-matrix(nrow=n,ncol=d)
for(i in seq(n))
{
mat[i,] <- rbinom(n=d, size=1, prob=0.5)
}
mat[,1]<-mat[,2] | mat[,3]
mat[,4] <- !mat[,2] | mat[,5]
i=2
j=1
print(sprintf("i%d,j%d",i,j))
bIndpTest(mat,i,j)
View(indpFunc)
library(BiCausality)
n<-500
d<-10
mat<-matrix(nrow=n,ncol=d)
for(i in seq(n))
{
mat[i,] <- rbinom(n=d, size=1, prob=0.5)
}
mat[,1]<-mat[,2] | mat[,3]
mat[,4] <- !mat[,2] | mat[,5]
i=2
j=1
print(sprintf("i%d,j%d",i,j))
bIndpTest(mat,i,j)
i=2
j=4
print(sprintf("i%d,j%d",i,j))
bIndpTest(mat,i,j)
i=2
j=3
print(sprintf("i%d,j%d",i,j))
bIndpTest(mat,i,j)
i=4
j=1
print(sprintf("i%d,j%d",i,j))
bIndpTest(mat,i,j)
i=4
j=1
z<-numeric(d)-1
z[2]<-1
print(sprintf("i%d,j%d",i,j))
bIndpTest(mat,i,j,z=z)
i=2
j=3
z<-numeric(d)-1
z[1]<-0
print(sprintf("i%d,j%d",i,j))
bIndpTest(mat,i,j,z=z)
# bSCMDepndentGraphFunc<-function(mat,nboot=100,alpha=0.05,IndpThs=0.05)
# {
#   n<-dim(mat)[1]
#   d<-dim(mat)[2]
#   nMatboot<-list()
#   Dboot<-list()
#   bDx<-matrix(0,nboot,n)
#   # == Create the bootstrapping sequence of D
#   for(k in seq(nboot))
#   {
#     bDx[k,]<-sample(1:n,length(1:n),replace = TRUE)
#     nMatboot[[k]]<-mat[bDx[k,],]
#     Dboot[[k]]<-VecAlignment(nMatboot[[k]])
#   }
#   #Check dependency of all pairwises
#   E0<-matrix(0,nrow=d,ncol=d) # save mean
#   depInfo<-list()
#
#   for(i in seq(d-1))
#     for(j in seq(i+1,d))
#     {
#       str<-sprintf("%d,%d",i,j)
#       print(str)
#       bIndpDist<-numeric(nboot)
#       for(k in seq(nboot))
#       {
#         D<-Dboot[[k]]
#         bIndpDist[k]<-indpFunc(D,i,j)
#       }
#       testRes<-wilcox.test(x=bIndpDist, mu = IndpThs, alternative = "greater")
#       confInv<-quantile(bIndpDist, c(0+alpha/2, 1-alpha/2))
#       bmean <- mean(bIndpDist)
#
#       #check whether i is dependent with j
#       if(testRes$p.value<=alpha)
#       {
#         E0[i,j]<-1
#         E0[j,i]<-1
#         depInfo[[str]]$bmean<-bmean
#         depInfo[[str]]$confInv<-confInv
#         depInfo[[str]]$testRes<-testRes
#         depInfo[[str]]$indices<-c(i,j)
#       }
#     }
#   return(list(E0=E0,depInfo=depInfo,Dboot=Dboot) )
# }
library(BiCausality)
library(devtools)
devtools::document()
# bSCMDepndentGraphFunc<-function(mat,nboot=100,alpha=0.05,IndpThs=0.05)
# {
#   n<-dim(mat)[1]
#   d<-dim(mat)[2]
#   nMatboot<-list()
#   Dboot<-list()
#   bDx<-matrix(0,nboot,n)
#   # == Create the bootstrapping sequence of D
#   for(k in seq(nboot))
#   {
#     bDx[k,]<-sample(1:n,length(1:n),replace = TRUE)
#     nMatboot[[k]]<-mat[bDx[k,],]
#     Dboot[[k]]<-VecAlignment(nMatboot[[k]])
#   }
#   #Check dependency of all pairwises
#   E0<-matrix(0,nrow=d,ncol=d) # save mean
#   depInfo<-list()
#
#   for(i in seq(d-1))
#     for(j in seq(i+1,d))
#     {
#       str<-sprintf("%d,%d",i,j)
#       print(str)
#       bIndpDist<-numeric(nboot)
#       for(k in seq(nboot))
#       {
#         D<-Dboot[[k]]
#         bIndpDist[k]<-indpFunc(D,i,j)
#       }
#       testRes<-wilcox.test(x=bIndpDist, mu = IndpThs, alternative = "greater")
#       confInv<-quantile(bIndpDist, c(0+alpha/2, 1-alpha/2))
#       bmean <- mean(bIndpDist)
#
#       #check whether i is dependent with j
#       if(testRes$p.value<=alpha)
#       {
#         E0[i,j]<-1
#         E0[j,i]<-1
#         depInfo[[str]]$bmean<-bmean
#         depInfo[[str]]$confInv<-confInv
#         depInfo[[str]]$testRes<-testRes
#         depInfo[[str]]$indices<-c(i,j)
#       }
#     }
#   return(list(E0=E0,depInfo=depInfo,Dboot=Dboot) )
# }
library(BiCausality)
n<-500
d<-10
mat<-matrix(nrow=n,ncol=d)
for(i in seq(n))
{
mat[i,] <- rbinom(n=d, size=1, prob=0.5)
}
mat[,1]<-mat[,2] | mat[,3]
mat[,4] <- !mat[,6] | mat[,5]
res<-bSCMDepndentGraphFunc(mat)
resO<-bSCMDepndentGraphFastFunc(mat)
res
# bSCMDepndentGraphFunc<-function(mat,nboot=100,alpha=0.05,IndpThs=0.05)
# {
#   n<-dim(mat)[1]
#   d<-dim(mat)[2]
#   nMatboot<-list()
#   Dboot<-list()
#   bDx<-matrix(0,nboot,n)
#   # == Create the bootstrapping sequence of D
#   for(k in seq(nboot))
#   {
#     bDx[k,]<-sample(1:n,length(1:n),replace = TRUE)
#     nMatboot[[k]]<-mat[bDx[k,],]
#     Dboot[[k]]<-VecAlignment(nMatboot[[k]])
#   }
#   #Check dependency of all pairwises
#   E0<-matrix(0,nrow=d,ncol=d) # save mean
#   depInfo<-list()
#
#   for(i in seq(d-1))
#     for(j in seq(i+1,d))
#     {
#       str<-sprintf("%d,%d",i,j)
#       print(str)
#       bIndpDist<-numeric(nboot)
#       for(k in seq(nboot))
#       {
#         D<-Dboot[[k]]
#         bIndpDist[k]<-indpFunc(D,i,j)
#       }
#       testRes<-wilcox.test(x=bIndpDist, mu = IndpThs, alternative = "greater")
#       confInv<-quantile(bIndpDist, c(0+alpha/2, 1-alpha/2))
#       bmean <- mean(bIndpDist)
#
#       #check whether i is dependent with j
#       if(testRes$p.value<=alpha)
#       {
#         E0[i,j]<-1
#         E0[j,i]<-1
#         depInfo[[str]]$bmean<-bmean
#         depInfo[[str]]$confInv<-confInv
#         depInfo[[str]]$testRes<-testRes
#         depInfo[[str]]$indices<-c(i,j)
#       }
#     }
#   return(list(E0=E0,depInfo=depInfo,Dboot=Dboot) )
# }
library(BiCausality)
n<-500
d<-10
mat<-matrix(nrow=n,ncol=d)
for(i in seq(n))
{
mat[i,] <- rbinom(n=d, size=1, prob=0.5)
}
mat[,1]<-mat[,2] | mat[,3]
mat[,4] <- !mat[,6] | mat[,5]
res<-bSCMDepndentGraphFunc(mat)
resO<-bSCMDepndentGraphFastFunc(mat)
document()
# bSCMDepndentGraphFunc<-function(mat,nboot=100,alpha=0.05,IndpThs=0.05)
# {
#   n<-dim(mat)[1]
#   d<-dim(mat)[2]
#   nMatboot<-list()
#   Dboot<-list()
#   bDx<-matrix(0,nboot,n)
#   # == Create the bootstrapping sequence of D
#   for(k in seq(nboot))
#   {
#     bDx[k,]<-sample(1:n,length(1:n),replace = TRUE)
#     nMatboot[[k]]<-mat[bDx[k,],]
#     Dboot[[k]]<-VecAlignment(nMatboot[[k]])
#   }
#   #Check dependency of all pairwises
#   E0<-matrix(0,nrow=d,ncol=d) # save mean
#   depInfo<-list()
#
#   for(i in seq(d-1))
#     for(j in seq(i+1,d))
#     {
#       str<-sprintf("%d,%d",i,j)
#       print(str)
#       bIndpDist<-numeric(nboot)
#       for(k in seq(nboot))
#       {
#         D<-Dboot[[k]]
#         bIndpDist[k]<-indpFunc(D,i,j)
#       }
#       testRes<-wilcox.test(x=bIndpDist, mu = IndpThs, alternative = "greater")
#       confInv<-quantile(bIndpDist, c(0+alpha/2, 1-alpha/2))
#       bmean <- mean(bIndpDist)
#
#       #check whether i is dependent with j
#       if(testRes$p.value<=alpha)
#       {
#         E0[i,j]<-1
#         E0[j,i]<-1
#         depInfo[[str]]$bmean<-bmean
#         depInfo[[str]]$confInv<-confInv
#         depInfo[[str]]$testRes<-testRes
#         depInfo[[str]]$indices<-c(i,j)
#       }
#     }
#   return(list(E0=E0,depInfo=depInfo,Dboot=Dboot) )
# }
library(BiCausality)
n<-500
d<-10
mat<-matrix(nrow=n,ncol=d)
for(i in seq(n))
{
mat[i,] <- rbinom(n=d, size=1, prob=0.5)
}
mat[,1]<-mat[,2] | mat[,3]
mat[,4] <- !mat[,6] | mat[,5]
res<-bSCMDepndentGraphFunc(mat)
resO<-bSCMDepndentGraphFastFunc(mat)
res$E0pval
res$E0
res$E0lowbound
load("~/Documents/GitHub/BiCausality/res40.rdata")
library(BiCausality)
# alpha=0.05
# nboot=100
# IndpThs=0.05
# CausalThs = 0.25
# slack=0.001
# res50<-bSCMDepndentGraphFunc(mat = mat50, pflag=TRUE,IndpThs =0.01)
# print("Removing confounder(s)")
# res50_2<-BiCausality::bSCMdeConfoundingGraphFunc(res50,IndpThs=IndpThs,alpha=alpha)
# print("Inferring causal graph")
# res50_3<-BiCausality::bSCMCausalGraphFunc(res50_2$E1,res50$Dboot ,alpha=alpha,SignThs=IndpThs,CausalThs = CausalThs,slack=slack)
res40final<-BiCausality::CausalGraphInferMainFunc(mat = mat40)
res40final$CausalGRes$Ehat
res40final$depRes
res40final$depRes$E0
res40final$ConfoundRes$E1
res40final$ConfoundRes$E2
res40final$CausalGRes$causalInfo
res40final$CausalGRes
res40final$ConfoundRes$E1
save(res40,mat40,file = "res40.rdata")
library(BiCausality)
# alpha=0.05
# nboot=100
# IndpThs=0.05
# CausalThs = 0.25
# slack=0.001
# res50<-bSCMDepndentGraphFunc(mat = mat50, pflag=TRUE,IndpThs =0.01)
# print("Removing confounder(s)")
# res50_2<-BiCausality::bSCMdeConfoundingGraphFunc(res50,IndpThs=IndpThs,alpha=alpha)
# print("Inferring causal graph")
# res50_3<-BiCausality::bSCMCausalGraphFunc(res50_2$E1,res50$Dboot ,alpha=alpha,SignThs=IndpThs,CausalThs = CausalThs,slack=slack)
res50final<-BiCausality::CausalGraphInferMainFunc(mat = mat50)
load("~/Documents/GitHub/BiCausality/res40.rdata")
save(res40,mat40,file = "res40final.rdata")
save(res40final.rdata,mat40,file = "res40final.rdata")
save(res40final,mat40,file = "res40final.rdata")
load("~/Documents/GitHub/BiCausality/res50.rdata")
library(BiCausality)
# alpha=0.05
# nboot=100
# IndpThs=0.05
# CausalThs = 0.25
# slack=0.001
# res50<-bSCMDepndentGraphFunc(mat = mat50, pflag=TRUE,IndpThs =0.01)
# print("Removing confounder(s)")
# res50_2<-BiCausality::bSCMdeConfoundingGraphFunc(res50,IndpThs=IndpThs,alpha=alpha)
# print("Inferring causal graph")
# res50_3<-BiCausality::bSCMCausalGraphFunc(res50_2$E1,res50$Dboot ,alpha=alpha,SignThs=IndpThs,CausalThs = CausalThs,slack=slack)
res50final<-BiCausality::CausalGraphInferMainFunc(mat = mat50)
res50final$CausalGRes$Ehat
res50final$depRes$E0
sum(res50final$depRes$E0)
save(res50final,mat50,file="res50Final.Rdata")
save(res50final,mat50,file="res50Final.Rdata")
sum(res40final$depRes$E0)
sum(res40final$CausalGRes$Ehat)
sum(res50final$depRes$E0)
sum(res50final$CausalGRes$Ehat)
save(res50final,mat50,file="res50Final.Rdata")
