---
title: "EXP Notebook"
output: html_notebook
---

Experiment notebook
```{r}
library(devtools)
devtools::document()
```

load
```{r}
load("TPMAPdata61.rdata")
```
cleansing
```{r}
mat40<-as.data.frame(DataTProv40$P)
for(i in seq(31))
{
 mode(mat40[,i])= "numeric"
  mat40[is.na(mat40[,i]), i] = 0
  print(sprintf("%d",i )  )
  print(unique(mat40[,i]))
}
mat40<-as.matrix(mat40)
```
mining
```{r}
library(BiCausality)
# alpha=0.05
# nboot=100
# IndpThs=0.05
# CausalThs = 0.25
# slack=0.001
# res50<-bSCMDepndentGraphFunc(mat = mat50, pflag=TRUE,IndpThs =0.01)
# print("Removing confounder(s)")
# res50_2<-BiCausality::bSCMdeConfoundingGraphFunc(res50,IndpThs=IndpThs,alpha=alpha)
# print("Inferring causal graph")
# res50_3<-BiCausality::bSCMCausalGraphFunc(res50_2$E1,res50$Dboot ,alpha=alpha,SignThs=IndpThs,CausalThs = CausalThs,slack=slack)

res50final<-BiCausality::CausalGraphInferMainFunc(mat = mat50)
```

# run this first -> implementation of confNetFunc
```{r}
library(BiCausality)
confNetFunc<-function(mat,IndpThs=0.1)
{
  d<-dim(mat)[2]
  confNet<-matrix(0,nrow=d,ncol=d)
  D<-VecAlignment(mat)
  confValMat<-matrix(0,nrow=d,ncol=d)
  #===
  for(i in seq(d-1))
    for(j in seq(i+1,d))
    {
      z<-numeric(d)-1
      y<-numeric(d)-1
      y[j]<-c(1)
      z[i]<-c(1)
      a1<-CondProb(D,y=y,z=z)$condP # conf(y|z)
      b1<-CondProb(D,y=z,z=y)$condP # conf(z|y) 
      confValMat[i,j]<-a1
      confValMat[j,i]<-b1
      if((a1-b1)>0 && a1>=IndpThs)
        confNet[i,j]<-1
      else if((b1-a1)>0 && b1>= IndpThs)
        confNet[j,i]<-1
      else
        confNet[i,j]<-0
    }
  return(list(confNet=confNet,confValMat=confValMat) )
}

# set.seed(2022)
seedN<-2022

n<-500
d<-10
mat<-matrix(nrow=n,ncol=d)

for(i in seq(n))
{
  set.seed(seedN+i)
  mat[i,] <- rbinom(n=d, size=1, prob=0.5)
}
mat[,1]<-mat[,2] | mat[,3] 
mat[,4] <-mat[,2] | mat[,5]
mat[,6] <- mat[,1] | mat[,4]

trueMat<-matrix(nrow=d,ncol=d,0)
trueMat[c(2,3),1]<-1
trueMat[c(2,5),4]<-1
trueMat[c(1,4),6]<-1
trsTrueMat<-getTransitiveClosureMat(trueMat)

res<-confNetFunc(mat=mat,IndpThs=0.9)
res$confNet
res$confValMat # baseline
print("baseline trs mat")
print( comparePredAdjMatrix2TrueAdjMat(trueAdjMat=trsTrueMat, adjMat = getTransitiveClosureMat(res$confNet) ) )
print("baseline directed mat")
print( comparePredAdjMatrix2TrueAdjMat(trueAdjMat=trueMat, adjMat = res$confNet ) )

resC<-BiCausality::CausalGraphInferMainFunc(mat = mat,CausalThs=0.1)
resC$CausalGRes$Ehat # proposed method

cMat<- resC$CausalGRes$Ehat
print("proposed method trs mat")
print( comparePredAdjMatrix2TrueAdjMat(trueAdjMat=trsTrueMat, adjMat = getTransitiveClosureMat(cMat) ) )
print("proposed method directed mat")
print( comparePredAdjMatrix2TrueAdjMat(trueAdjMat=trueMat, adjMat = cMat) )
```
# Second exp on sim -> down prob of being 1 in sim to 0.1
```{r}
# set.seed(2022)
# set.seed(2022)
seedN<-2022

n<-500
d<-10
mat<-matrix(nrow=n,ncol=d)

for(i in seq(n))
{
  set.seed(seedN+i)
  mat[i,] <- rbinom(n=d, size=1, prob=0.1)
}
mat[,1]<-mat[,2] | mat[,3] 
mat[,4] <-mat[,2] | mat[,5]
mat[,6] <- mat[,1] | mat[,4]

trueMat<-matrix(nrow=d,ncol=d,0)
trueMat[c(2,3),1]<-1
trueMat[c(2,5),4]<-1
trueMat[c(1,4),6]<-1
trsTrueMat<-getTransitiveClosureMat(trueMat)

res<-confNetFunc(mat=mat,IndpThs=0.9)
res$confNet
res$confValMat # baseline
print("baseline trs mat")
print( comparePredAdjMatrix2TrueAdjMat(trueAdjMat=trsTrueMat, adjMat = getTransitiveClosureMat(res$confNet) ) )
print("baseline directed mat")
print( comparePredAdjMatrix2TrueAdjMat(trueAdjMat=trueMat, adjMat = res$confNet ) )

resC<-BiCausality::CausalGraphInferMainFunc(mat = mat,CausalThs=0.1)
resC$CausalGRes$Ehat # proposed method

cMat<- resC$CausalGRes$Ehat
print("proposed method trs mat")
print( comparePredAdjMatrix2TrueAdjMat(trueAdjMat=trsTrueMat, adjMat = getTransitiveClosureMat(cMat) ) )
print("proposed method directed mat")
print( comparePredAdjMatrix2TrueAdjMat(trueAdjMat=trueMat, adjMat = cMat) )
```
# Third exp on sim -> down prob of being 1 in sim to 0.08
```{r}
# set.seed(2022)
seedN<-2022

n<-500
d<-10
mat<-matrix(nrow=n,ncol=d)

for(i in seq(n))
{
  set.seed(seedN+i)
  mat[i,] <- rbinom(n=d, size=1, prob=0.08)
}
mat[,1]<-mat[,2] | mat[,3] 
mat[,4] <-mat[,2] | mat[,5]
mat[,6] <- mat[,1] | mat[,4]

trueMat<-matrix(nrow=d,ncol=d,0)
trueMat[c(2,3),1]<-1
trueMat[c(2,5),4]<-1
trueMat[c(1,4),6]<-1
trsTrueMat<-getTransitiveClosureMat(trueMat)

res<-confNetFunc(mat=mat,IndpThs=0.9)
res$confNet
res$confValMat # baseline
print("baseline trs mat")
print( comparePredAdjMatrix2TrueAdjMat(trueAdjMat=trsTrueMat, adjMat = getTransitiveClosureMat(res$confNet) ) )
print("baseline directed mat")
print( comparePredAdjMatrix2TrueAdjMat(trueAdjMat=trueMat, adjMat = res$confNet ) )

resC<-BiCausality::CausalGraphInferMainFunc(mat = mat,CausalThs=0.1)
resC$CausalGRes$Ehat # proposed method

cMat<- resC$CausalGRes$Ehat
print("proposed method trs mat")
print( comparePredAdjMatrix2TrueAdjMat(trueAdjMat=trsTrueMat, adjMat = getTransitiveClosureMat(cMat) ) )
print("proposed method directed mat")
print( comparePredAdjMatrix2TrueAdjMat(trueAdjMat=trueMat, adjMat = cMat) )
```
# Fourth exp on sim -> down prob of being 1 in sim to 0.05
```{r}
# set.seed(2022)
seedN<-2022

n<-500
d<-10
mat<-matrix(nrow=n,ncol=d)

for(i in seq(n))
{
  set.seed(seedN+i)
  mat[i,] <- rbinom(n=d, size=1, prob=0.05)
}
mat[,1]<-mat[,2] | mat[,3] 
mat[,4] <-mat[,2] | mat[,5]
mat[,6] <- mat[,1] | mat[,4]

trueMat<-matrix(nrow=d,ncol=d,0)
trueMat[c(2,3),1]<-1
trueMat[c(2,5),4]<-1
trueMat[c(1,4),6]<-1
trsTrueMat<-getTransitiveClosureMat(trueMat)

res<-confNetFunc(mat=mat,IndpThs=0.9)
res$confNet
res$confValMat # baseline
print("baseline trs mat")
print( comparePredAdjMatrix2TrueAdjMat(trueAdjMat=trsTrueMat, adjMat = getTransitiveClosureMat(res$confNet) ) )
print("baseline directed mat")
print( comparePredAdjMatrix2TrueAdjMat(trueAdjMat=trueMat, adjMat = res$confNet ) )

resC<-BiCausality::CausalGraphInferMainFunc(mat = mat,CausalThs=0.1)
resC$CausalGRes$Ehat # proposed method

cMat<- resC$CausalGRes$Ehat
print("proposed method trs mat")
print( comparePredAdjMatrix2TrueAdjMat(trueAdjMat=trsTrueMat, adjMat = getTransitiveClosureMat(cMat) ) )
print("proposed method directed mat")
print( comparePredAdjMatrix2TrueAdjMat(trueAdjMat=trueMat, adjMat = cMat) )
```
# Fifth exp on sim -> down prob of being 1 in sim to 0.08 n:100,250,500,750,1000
```{r}
# set.seed(2022)
seedN<-2022

n<-1000
d<-10
mat<-matrix(nrow=n,ncol=d)

for(i in seq(n))
{
  set.seed(seedN+i)
  mat[i,] <- rbinom(n=d, size=1, prob=0.08)
}
mat[,1]<-mat[,2] | mat[,3] 
mat[,4] <-mat[,2] | mat[,5]
mat[,6] <- mat[,1] | mat[,4]

trueMat<-matrix(nrow=d,ncol=d,0)
trueMat[c(2,3),1]<-1
trueMat[c(2,5),4]<-1
trueMat[c(1,4),6]<-1
trsTrueMat<-getTransitiveClosureMat(trueMat)

res<-confNetFunc(mat=mat,IndpThs=0.9)
res$confNet
res$confValMat # baseline
print("baseline trs mat")
print( comparePredAdjMatrix2TrueAdjMat(trueAdjMat=trsTrueMat, adjMat = getTransitiveClosureMat(res$confNet) ) )
print("baseline directed mat")
print( comparePredAdjMatrix2TrueAdjMat(trueAdjMat=trueMat, adjMat = res$confNet ) )

resC<-BiCausality::CausalGraphInferMainFunc(mat = mat,CausalThs=0.1)
resC$CausalGRes$Ehat # proposed method

cMat<- resC$CausalGRes$Ehat
print("proposed method trs mat")
print( comparePredAdjMatrix2TrueAdjMat(trueAdjMat=trsTrueMat, adjMat = getTransitiveClosureMat(cMat) ) )
print("proposed method directed mat")
print( comparePredAdjMatrix2TrueAdjMat(trueAdjMat=trueMat, adjMat = cMat) )
```
# Implementation of causal rule approach
```{r}
library(BiCausality)
oddRatioCausalRuleFunc<-function(D,i,j,z=c(),slack=0.001)
{
  d<-length(D[[1]]$name)
  if(is.null(z))
    z<-numeric(d)-1

  res<-CondProb(D,y=numeric(d)-1,z=z)
  D<-res$nD
  n<-res$countTotal
  L<-length(D)

  oddMagitude<-0

  z1<-numeric(d)-1
  y<-numeric(d)-1

  y[c(i,j)]<-c(0,0)
  a1<-CondProb(D,y,z1)$count
  y[c(i,j)]<-c(1,1)
  b1<-CondProb(D,y,z1)$count
  y[c(i,j)]<-c(1,0)
  c1<-CondProb(D,y,z1)$count
  y[c(i,j)]<-c(0,1)
  d1<-CondProb(D,y,z1)$count
  return(   (a1+b1+slack)/(c1+d1+slack) )
}
causalRuleFunc<-function(mat,oddThs=0.1,slack=0.001)
{
  d<-dim(mat)[2]
  confNet<-matrix(0,nrow=d,ncol=d)
  D<-VecAlignment(mat)
  confValMat<-matrix(0,nrow=d,ncol=d)
  oddValMat<-matrix(0,nrow=d,ncol=d)
  #===
  for(i in seq(d-1))
    for(j in seq(i+1,d))
    {
      z<-numeric(d)-1
      y<-numeric(d)-1
      y[j]<-c(1)
      z[i]<-c(1)
      
      oddVal<-oddRatioCausalRuleFunc(D,i,j)
      a1<-CondProb(D,y=y,z=z)$condP # conf(y|z)
      b1<-CondProb(D,y=z,z=y)$condP # conf(z|y) 
      confValMat[i,j]<-a1
      confValMat[j,i]<-b1
      
      oddValMat[i,j]<-oddVal
      oddValMat[j,i]<-oddVal
      if((a1-b1)>0  && oddVal> oddThs)
        confNet[i,j]<-1
      else if((b1-a1)>0 && oddVal > oddThs)
        confNet[j,i]<-1
      else
        confNet[i,j]<-0
    }
  return(list(confNet=confNet,confValMat=confValMat, oddValMat=oddValMat) )
}

# set.seed(2022)
seedN<-2022
probTHS<-0.08

n<-500
d<-10
mat<-matrix(nrow=n,ncol=d)

for(i in seq(n))
{
  set.seed(seedN+i)
  mat[i,] <- rbinom(n=d, size=1, prob=probTHS)
}
mat[,1]<-mat[,2] | mat[,3] 
mat[,4] <-mat[,2] | mat[,5]
mat[,6] <- mat[,1] | mat[,4]

trueMat<-matrix(nrow=d,ncol=d,0)
trueMat[c(2,3),1]<-1
trueMat[c(2,5),4]<-1
trueMat[c(1,4),6]<-1
trsTrueMat<-getTransitiveClosureMat(trueMat)

res<-causalRuleFunc(mat=mat,oddThs=1/2.5^log(probTHS))
res$confNet
res$confValMat # baseline
print("baseline trs mat")
print( comparePredAdjMatrix2TrueAdjMat(trueAdjMat=trsTrueMat, adjMat = getTransitiveClosureMat(res$confNet) ) )
print("baseline directed mat")
print( comparePredAdjMatrix2TrueAdjMat(trueAdjMat=trueMat, adjMat = res$confNet ) )

# resC<-BiCausality::CausalGraphInferMainFunc(mat = mat,CausalThs=0.1)
# resC$CausalGRes$Ehat # proposed method
# 
# cMat<- resC$CausalGRes$Ehat
# print("proposed method trs mat")
# print( comparePredAdjMatrix2TrueAdjMat(trueAdjMat=trsTrueMat, adjMat = getTransitiveClosureMat(cMat) ) )
# print("proposed method directed mat")
# print( comparePredAdjMatrix2TrueAdjMat(trueAdjMat=trueMat, adjMat = cMat) )
```
Experiment code: not use
```{r}
findMatch<-function(D,vec)
{
  L<-length(D)
  inx<--1
  for(i in seq(L) ) 
  {
    if(sum(D[[i]]$name ==vec) ==length(vec))
    {
      inx<-i
      break;
    }
  }
  return(inx)
}
LHSinx<-2
RHSinx<-1
D<-VecAlignment(mat)
  L<-length(D)
  #P->Z
  markVec<-!logical(L)
  
  C1=C0=C11=C10=C01=C00=0
  for(i in seq(L) ) #For each unique binary nD[[i]] in nD
  {
    if(markVec[i]==TRUE)
    {
      vec1<-D[[i]]$name
      a11=a10=a01=a00=vec1
      
      a11[c(LHSinx,RHSinx)]<-c(1,1)
      a10[c(LHSinx,RHSinx)]<-c(1,0)
      a01[c(LHSinx,RHSinx)]<-c(0,1)
      a00[c(LHSinx,RHSinx)]<-c(0,0)
      
      i11<-findMatch(D,a11)
      i10<-findMatch(D,a10)
      i01<-findMatch(D,a01)
      i00<-findMatch(D,a00)
      
      markVec[i11]=markVec[i10]=markVec[i01]=markVec[i00]=FALSE
      c11=c10=c01=c00=0
      
      if(i11!=-1) 
        c11<-D[[i11]]$count
      if(i10!=-1) 
        c10<-D[[i10]]$count
      if(i01!=-1) 
      {
        c01<-D[[i01]]$count
      }
      if(i00!=-1) 
        c00<-D[[i00]]$count
      c1=c11+c10
      c0=c01+c00
      
      if(min(c1,c0)==0) 
        next
      diff1=abs(c1-c0)
      if(c1>c0)
      {
         c11=c11-floor(diff1/2)
         c10=c10-ceiling(diff1/2)
         c1=c1-diff1
      }
      else if(c1<c0)
      {
        c00=c00-floor(diff1/2)
        c01=c01-ceiling(diff1/2)
        c0=c0-diff1
      }
      
      C1=C1+c1
      C0=C0+c0
      C11=C11+c11
      C10=C10+c10
      C01=C01+c01
      C00=C00+c00
    }
    oddVal<- (C11+C00)/(C01+C10)
  }

 
```

